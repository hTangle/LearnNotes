### CPU的态(Mode)
* CPU的工作状态
* 对资源和指令使用权限的描述

核态(Kernel Mode)
用户态(User mod)

硬件按照态，OS按照进程

### 中断

### 实模式(Real Mode)和保护模式(Protect Mode)

#### 系统BIOS(Basic I/O System)
* 基本输入输出系统
* 位置:F0000-FFFFF
* 功能：
  * 系统启动配置
  * 基本的设备IO服务
  * 系统的加点自检和启动

#### 主启动记录MBR
* 存放在首扇区
* 存放和OS启动的相关信息
* 521BYTES
* 结束 0xAA55H

分区启动扇区(Partition Boot Sector)：BootLoader PBR

POST(加电自检)->CMOS->MBR->PBR

### 死锁
#### 起因
1. 资源有限
2. 并发进程推进顺序不当

#### 条件
1. 互斥条件
2. 不剥夺条件
3. 部分分配条件
4. 环路条件

## 进程的调度算法
* 先来先服务调度(First Come First Server):不利于短作业
* 短作业优先调度(Short Job First):忽视作业的等待时间，饥饿现象
* 响应比高者优先调度算法:(等待时间+运行时间)/运行时间，有利于短作业，有利于等候长作业
* 优先数调度算法:静态优先数和动态优先数
* 循环轮转调度法(Round-Robin):先进先出队列，新进程加到队列末尾，按照时间片q为单位轮转调度，q太大会退化为FCFS

## Linux进程调度
* 普通进程：动态优先级调度，按照调度策略来改变
* 实时进程：静态优先级
  * SCHED_FIFO:先进先出
  * SCHED_RR:时间片轮转

__子进程新建时的counter是父进程的一半__

## 进程的切换
1. 正在运行用户态进程A
2. 发生中断
   1. 保存Current当前进程的cs:eip/esp/eflags到内核堆栈
   2. 从内核堆栈装入ISR中断服务例程的cs:eip和ss:esp
3. SAVE_ALL
4. 中断处理过程中或中断返回前调用schedule(),switch_to做了进程上下文切换
5. 运行用户态进程B
6. Restore__ALL
7. iret
8. 继续运行用户态进程B

## 存储管理的功能：地址映射
1. 固定地址映射
2. 静态地址映射:程序占用连续内存空间
   1. 逻辑地址(VA, Virtual Addr)
   2. 装入地址(BA, Base Addr)
   3. 物理地址(MA, Memory Addr)
   4. MA=BA+VA
3. 动态地址映射：执行过程中把逻辑地址转换为物理地址
   1. MA=BA+VA 自动计算MA
   2. 需要内存管理(MMU)支持

## 存储管理功能：虚拟存储
* 封闭空间
* 物理地址分离

## 存储管理功能：内存分配功能
## 存储管理功能：存储保护功能

## 空闲区表排序策略
* 首次适应法：按照首地址递增排序，尽可能使用低地址
* 最佳适应法：按大小递增排序，尽可能使用较小空闲分区(最容易产生碎片)
* 最坏适应法：按照大小递减，仅需查找一次

## 分区回收：释放区更新大小位置插入等

## 覆盖(Overlay)：常驻区和覆盖区
* 通过程序的模块设计可以适应覆盖技术
* 编程复杂
* 程序执行时间长

## 交换(Swapping):内存不够时将进程写道磁盘，当进程要运行时重新写回内存

## 内存碎片-类似于Stop the world
* 规定门限值
* 内存拼接技术
* 解除程序需要占用连续内存

# 虚拟内存管理
## 页式虚拟存储管理
* 把进程空间和内存空间分为等大小的页框
* 进程以页为单位装入内存
* 内存以页框为单位分配使用

## 页表和页式地址映射
虚拟地址VA可以分为页号P和业内偏移W
P=VA>>n
W=VA&&(2^n-1)
### 页面映射表
页号-页框号-其他特性
### 页式地址映射
虚拟地址->物理地址
1. 从VA分离页号P和W
2. 查页表，以P为索引查页框号P'
3. 计算物理地址MA=P'<<n+W
> Move R1,[2500]
> 
> P=2500>>10=2 
> 
> W=2500&&(1024-1)=452
> 
> 查页表P=2 P'=7
> 
> MA=7<<10+452=7620

## 块表(Cache)

## 缺页中断
* 缺页率

## 页面淘汰策略
