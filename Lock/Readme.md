### 线程的中断
1. Object类的wait(),wait(long),wait(long,int),Thread join(),sleep()
2. 实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等
3.  Selector 中的 select 方法:一旦中断，方法立即返回
#### 对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），并且在做出相应的操作后都会重置中断状态为 false。
**唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true**
**Lock方法不响应中断，但是会记录中断信息**

### 锁
> 线程执行到临界区的时候，会利用CAS将线程ID插入到Markword中，同时修改偏向锁的标志位
> CAS是乐观锁机制，读数据不加锁，写数据加锁，比较原值是否修改，ABA问题：版本号

* **锁膨胀**：两个线程竞争时，偏向锁会失效，升级为轻量级锁
* **轻量级锁**：乐观锁
 * **自旋锁**：当有另外一个线程来竞争锁时，这个线程会原地等待，而不是把该线程阻塞，直到获得锁的线程释放锁之后立即获得锁（消耗CPU）
 * **自适应锁**：动态根据实际情况改变自旋锁的等待次数，刚刚获得锁的线程会增加自旋次数，很长时间没有获得锁的自旋次数会减少直至升级为重量级锁
* **偏向锁**：锁会偏向于第一个获得它的线程，没有其他线程竞争则不会进行同步操作
* 偏向锁失效，会撤销锁
* **重量级锁**：轻量级锁膨胀之后会升级为重量级锁（互斥锁），会阻塞线程，唤起线程需要消耗资源（阻塞同步）

### 红黑树
* 根节点为黑
* 空叶为黑
* 红链接均为左链接
* 没有任何一个节点同时和两条红链接相连
* 完美黑色平衡树：任意空链接到根节点的路径上的黑链接数量相同

插入节点
Case 1	当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。	
(01) 将“父节点”设为黑色。
(02) 将“叔叔节点”设为黑色。
(03) 将“祖父节点”设为“红色”。
(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。

Case 2	当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子	
(01) 将“父节点”作为“新的当前节点”。
(02) 以“新的当前节点”为支点进行左旋。

Case 3	当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子	
(01) 将“父节点”设为“黑色”。
(02) 将“祖父节点”设为“红色”。
(03) 以“祖父节点”为支点进行右旋。

删除节点
Case 1	x是"黑+黑"节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。	
(01) 将x的兄弟节点设为“黑色”。
(02) 将x的父节点设为“红色”。
(03) 对x的父节点进行左旋。
(04) 左旋后，重新设置x的兄弟节点。

Case 2	x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。	
(01) 将x的兄弟节点设为“红色”。
(02) 设置“x的父节点”为“新的x节点”。

Case 3	x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。	
(01) 将x兄弟节点的左孩子设为“黑色”。
(02) 将x兄弟节点设为“红色”。
(03) 对x的兄弟节点进行右旋。
(04) 右旋后，重新设置x的兄弟节点。

Case 4	x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。	
(01) 将x父节点颜色 赋值给 x的兄弟节点。
(02) 将x父节点设为“黑色”。
(03) 将x兄弟节点的右子节设为“黑色”。
(04) 对x的父节点进行左旋。
(05) 设置“x”为“根节点”。

### ThreadLocal
* Thread类中有一个成员变量属于ThreadLocalMap类(一个定义在ThreadLocal类中的内部类)，它是一个Map，他的key是ThreadLocal实例对象。
* 当为ThreadLocal类的对象set值时，首先获得当前线程的ThreadLocalMap类属性，然后以ThreadLocal类的对象为key，设定value。get值时则类似。
* ThreadLocal变量的活动范围为某线程，是该线程“专有的，独自霸占”的，对该变量的所有操作均由该线程完成！也就是说，ThreadLocal 不是用来解决共享对象的多线程访问的竞争问题的，因为ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。当线程终止后，这些值会作为垃圾回收。
* 需要重写clone
* 但是如何保证两个同时实例化的ThreadLocal对象有不同的threadLocalHashCode属性：在ThreadLocal类中，还包含了一个static修饰的AtomicInteger（提供原子操作的Integer类）成员变量（即类变量）和一个static final修饰的常量（作为两个相邻nextHashCode的差值）。由于nextHashCode是类变量，所以每一次调用ThreadLocal类都可以保证nextHashCode被更新到新的值，并且下一次调用ThreadLocal类这个被更新的值仍然可用，同时AtomicInteger保证了nextHashCode自增的原子性。
* 线程结束时会被回收
* 初始容量16，负载因子2/3，解决冲突的方法是再hash法，也就是：在当前hash的基础上再自增一个常量。