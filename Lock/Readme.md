### 线程的中断
1. Object类的wait(),wait(long),wait(long,int),Thread join(),sleep()
2. 实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等
3.  Selector 中的 select 方法:一旦中断，方法立即返回
#### 对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），并且在做出相应的操作后都会重置中断状态为 false。
**唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true**
**Lock方法不响应中断，但是会记录中断信息**

### 锁
> 线程执行到临界区的时候，会利用CAS将线程ID插入到Markword中，同时修改偏向锁的标志位

* 锁膨胀：两个线程竞争时，偏向锁会失效，升级为轻量级锁
* 轻量级锁：乐观锁
 * 自旋锁：当有另外一个线程来竞争锁时，这个线程会原地等待，而不是把该线程阻塞，直到获得锁的线程释放锁之后立即获得锁（消耗CPU）
 * 自适应锁：动态根据实际情况改变自旋锁的等待次数，刚刚获得锁的线程会增加自旋次数，很长时间没有获得锁的自旋次数会减少直至升级为重量级锁
* 偏向锁：锁会偏向于第一个获得它的线程，没有其他线程竞争则不会进行同步操作
* 偏向锁失效，会撤销锁
* 重量级锁：轻量级锁膨胀之后会升级为重量级锁（互斥锁），会阻塞线程，唤起线程需要消耗资源（阻塞同步）
