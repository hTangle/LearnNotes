JVM
线程隔离区：虚拟机栈，本地方法栈，程序计数器
共享区：栈（存放对象实例和数组），方法区（加载的类信息，静态变量，常量，即时编译后的代码）

垃圾收集算法：
1）标记清除：空间碎片过多，效率不高
2）复制算法：可用内存缩小，对象存活率高时效率低
3）标记整理：老年代算法
4）分代收集

GC Roots：全局性的引用（常量，类静态变量），执行上下文
	• 虚拟机栈中引用的对象
	• 方法区中的类静态属性引用的对象
	• 方法区中常量引用的对象
	• 本地方法栈中JNI引用的对象

新生代和老年代的默认比例是1：2

新生代（Eden区（Java对象），ServivorFrom，ServivorTo）（8：1：1）
引用计数法，root搜索算法
### 垃圾收集器：
* 新生代：Serial ，ParNew，Parallel Scavenge
* 老年代：CMS，Serial Old MSC，Parallel Old

1. Serial：新生代采用复制算法，暂停所有用户线程，（Client模式下新生代的默认收集器）
2. ParNew收集器：Serial多线程版本，采用复制算法（多线程）（Server模式下新生代收集器）
3. Parallel Scavenge：复制算法，并行多线程，达到可控制的吞吐量（CPU用于运行用户代码的时间与消耗的总时间的比值）
4. Serial Old：单线程，标记整理算法（Client模式下虚拟机使用，与Parallel Scavenge搭配使用）
5. Parallel Old：老年代收集器，多线程，标记整理算法
6. CMS（Concurrent Mark Sweep）：最短停顿时间，老年代，标记清除算法，（初始标记stop the world，并发标记，重新标记stop the world，并发清除），对CPU资源敏感，无法处理浮动垃圾（并发清理阶段用户线程依然在运行），会产生大量碎片触发Full GC
7. G1收集器：并发与并行，分代收集，空间整合（整体上采用标记整理，局部采用复制算法），可预测的停顿（有计划的避免在整个Java堆中进行全区域的垃圾收集，通过维护优先列表，每次根据允许时间，回收价值最大的Region）（初始标记，并发标记，最终回收，筛选回收）
