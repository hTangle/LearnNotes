## OSI模型
OSI|TCP/IP|协议
---|:--:|:--:|---:
应用层|应用层|HTTP,SMTP,RTP,DNS
表示| |
会话| |
传输|传输层|TCP UDP
网络|网络层|IP ICMP
数据链路|数据链路层|DSL SONET 802.11
物理|物理层|

## IPv4
* 版本：记录数据报属于哪个协议版本
* IHL：指明头有多长，最小为5，头部没有可选项，最大为15，选项字段最多为40字节
* 区分服务：服务类型
* 总长度：最大长度为65535
* 标识：让目标主机确定一个新到达的分段属于哪一个数据报
* 未使用的位：
* DF：不分段
* MF：更多的段，除最后一个段之外其他都需要设置
* 分段偏移量：指明了该段在当前数据报中的偏移位置
* 生存期：限制数据包生存期计数器
* 协议：
* 头校验：所有的16位半字加起来取补码和为0
* 源地址：
* 目的地址：
* 选项：

#### 分层设计：
* 保持较少的路由前缀
* 不适合移动网络
* 浪费地址
----
* A类地址：1.0.0.0-127.255.255.255
* B类地址：128.0.0.0-191.255.255.255
* C类地址：192.0.0.0-223.255.255.255
* D类地址：240.0.0.0-239.255.255.255
* E类地址：240.0.0.0-255.255.255.255

## UDP(用户数据报协议)

## TCP(传输控制协议)
* 字节流
* 全双工，端到端
* 紧急数据(ugent data)处理：一个交互式用户键入Ctrl+C来中断一个已经开始运行的远程计算时，发送端程序把一些控制信息放在数据流中，并且将它连同URGENT标志一起交给TCP，这一事件将导致TCP停止积累数据，并将该连接上已有的所有数据立即传输出去，当接收方收到紧急数据后，接收端程序被中断，它停止当前正在完成的工作，并且读入数据流以便找到紧急数据，紧急数据的尾部应该被标记以便知道紧急数据的结束位置
* 20字节的头部
* 最多可达数据65535-20(IP)-20(TCP)=65495
### TCP报文格式
* 源端口：
* 目标端口：
* 序号(SEQ)和确认号(ack)：
* TCP头长度：指明TCP头包含多少个32位的字
* 没有被使用的4位：
* 8个1比特的标志位：CWR,ECE(拥塞控制),URG(紧急指针),ACK,PSH(推送数据),RST(拒接连接),SYN(建立连接过程),FIN(释放连接)
* 窗口大小：用于流量控制，为0时说明发送数据太多，接收不了了
* 校验和：
* 紧急指针：
* 选项：最大段长选项，时间戳选项(32位序号很快被消耗完，可以用时间戳来避免序号回绕问题)，选择确认：

### 三次握手
1. 客户端发送**SYN=1,seq=x，ACK=0**的TCP段请求连接-**SYN_SEND**
2. 服务端检查是否有进程监听端口，如果没有则发送一个RST=1的拒绝报文，如果有，接受请求时返回确认段**syn=1,seq=y,ack=x+1,ACK=1-SYN_RECV**
3. 客户端接收到确认段，返回**seq=x+1，ack=y+1,ACK=1**给服务端，建立连接-**ESTABLISHED**

### 四次挥手
1. 客户端发送**FIN=1,seq=u**，进入**FIN_WAIT_1**状态
2. 服务端接收到发送**ACK=1,seq=v,ack=u+1**进入**CLOSE_WAIT**状态
3. 客户端接收到之后进入**FIN_WAIT_2**状态，服务端发送完成以后发送**FIN=1,seq=w,ack=u+1**进入**LAST_ACK**状态
4. 客户端接收回复**ACK=1,seq=u+1,ack=w+1**进入**TIME_WAIT**状态，服务端收到以后进入**CLOSED**
5. 经过**2MSL**客户端关闭连接进入**CLOSED**状态

* 建立连接时可以将ACK和SYN一起发送，关闭连接时，服务器端可能不会立即关闭socket，这个时候需要先告诉客户端已经收到消息了，因此多了一次发送
* TIME_WAIT时间为2MSL(最大报文段生存时间):如果最后一个ACK丢失，服务端没有收到就会不断重发FIN报文，所以需要时间确认客户端是否重发报文
* 三次握手完成两个功能：确认双方彼此知道对方做好了发送数据的准备工作，而且允许双方进行初始序列号协商，为了防止已经失效的连接请求报文段突然又传送到服务端，会让服务端一直进行等待。

#### TCP粘包问题：发送方发送的若干数据包到接收方粘成一包，TCP一次发送多个分组，TCP应用层处理速度小于接收速度
> 解决方法：使用TCP_NODELAY ，文件不需要处理，读取发送长度，格式化数据

## HTTP:(应用层协议)
### HTTP1.0 请求-连接-释放
### HTTP1.1 持续连接，连接重用，流水线请求，设置保持时间

方法|描述
---|:--:|---:
get|获取资源，请求附在url后，传输容量有限制
post|传输实体文本，请求放置在HTTP报文实体里
head|没有实体，获取报文首部
put|传输文件
delete|删除文件
trace|追踪路径
connect|要求使用隧道协议连接代理
options|询问支持的方法

#### 响应码
代码|含义|例子
---|:--:|:--:|---:
1XX|信息|100=服务器同意处理客户请求
2XX|成功|200=请求成功，204=没有内容
3XX|重定向|301=移动页面，304=页面依然有效
4XX|客户错误|403=禁止页面，404=页面没找到
5XX|服务器错误|500=服务器内部错误，503=稍后再试

#### 缓存 Catch-Control
* 页面验证：通过缓存页面最初获取时返回的Expires头以及当前的日期和时间决定页面是否有效，启发式策略：如果页面一年内没有更新，则该页面在下一个小时内也不会更新
* 询问服务器缓存副本是否有效，**条件get**
* IF-modified-since Last-modified
* 请求验证缓存的副本

#### 连接步骤
1. 默认情况下客户端在端口80打开与服务器的一个TCP连接，URL可以指定其他端口
2. 客户端发送消息给服务端，请求指定路径上的资源，包括一个首部，可选地，还可以有一个空行，后面是请求的数据
3. 服务端向客户端发送响应，响应以响应码开头，后面是包含元数据的首部，一个空行以及锁请求的文档或错误信息
4. 服务器关闭连接

#### Cookie
* 只能是空白符的ASCII文本，不能包含逗号或分号
* 要在浏览器中设置cookie，服务器会在HTTP首部中包含Set-Cookie的首部行，浏览器再向服务器发送请求时会带上这个Cookie
* 作用域受到路径限制 Set-Cookie:user=elharo;Path=/restricted
* 设置子域 Set-Cookie:user=elharo;Domain=example.com
* 浏览器发送Cookie时需要注意Path再Domain前
* 设置Expires可以设置固定的过期点，Max-Age设置固定秒之后过期，也可以通过httponly设置只能通过http返回cookie

#### Session
* 服务端通过在用户登录时会新建一个session，同时为session分配一个ID：JSESSIONID，并将这个ID写入到cookie中，之后将这个cookie返回给浏览器，浏览器下次请求就会带有这个ID，之后通过ID就可以获取到用户的session了，当浏览器禁用cookie时需要用url重写，将JSESSIONID放入请求参数中
```
　　response.encodeRedirectURL(java.lang.String url) 用于对sendRedirect方法后的url地址进行重写。
　　response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写
```

### HTTPS
* 基于HTTP协议，通过SSL或TLS提供加密处理数据，验证对方身份以及数据完整性保护
* SSL为安全套阶层协议
* TLS为安全传输层协议
* 采用对称加密和非对称加密，数据是对称加密传输的，密钥是非对称加密的

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

> C<--Sp--S
> C --Sp+Cp-->S
> C --M+(Sp+Cp)-->S

> 对称加密：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。
> 其加密过程如下：明文 + 加密算法 + 私钥 => 密文
> 解密过程如下：密文 + 解密算法 + 私钥 => 明文
> 对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。
> 其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。

> 非对称加密：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。
> 被公钥加密过的密文只能被私钥解密，过程如下：
> 明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文
> 被私钥加密过的密文只能被公钥解密，过程如下：
> 明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文
> 由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。
> 非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
> 在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。